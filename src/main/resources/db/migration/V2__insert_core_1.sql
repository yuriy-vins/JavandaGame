-- src/main/resources/db/migration/V2__insert_core_1.sql
-- СORE-1
INSERT INTO answers (answer) VALUES (
'ООП - методология программирования, где программа может быть представлена в виде совокупности объектов,
каждый из которых является экземпляром определенного класса, и эти классы образуют иерархию наследования.
Согласно парадигме ООП программа состоит из обьектов, которые могут обмениваться сообщениями.
Обьекты могут обладать состоянием, и единственный способ изменить состояние обьекта - передать ему сообщение.
И в ответ на это сообщение обьект может изменить свое собственное состояние.
Класс — это описание еще не созданного объекта, как бы общий шаблон, состоящий из полей, методов и конструктора.
Объект – это экземпляр класса, созданный на основе этого описания(т.е. класса).'
);
INSERT INTO questions (question, answer_id) VALUES ('Что такое ООП?', 1);

INSERT INTO answers (answer) VALUES (
'Легко читается - не нужно выискивать в коде функции и выяснять, за что они отвечают.
Быстро пишется - можно быстро создать сущности, с которыми должна работать программа.
Простота реализации большого функционала - т.к. на написание кода уходит меньше времени, можно быстро создать
приложение с множеством возможностей. Меньше повторений кода - не нужно писать однотипные функции для разных сущностей.'
);
INSERT INTO questions (question, answer_id) VALUES ('Какие преимущества у ООП?', 2);

INSERT INTO answers (answer) VALUES (
'Снижает производительность - потому что многие вещи технически реализованы иначе, поэтому они используют больше ресурсов.
Сложно начать - парадигма ООП сложнее функционального программирования, поэтому на старт уходит больше времени.'
);
INSERT INTO questions (question, answer_id) VALUES ('Какие недостатки у ООП?', 3);

INSERT INTO answers (answer) VALUES (
'Инкапсуляция, Наследование, Полиморфизм. (И также дополнительно Абстракция).'
);
INSERT INTO questions (question, answer_id) VALUES ('Назовите основные принципы ООП.', 4);

INSERT INTO answers (answer) VALUES (
'Свойство системы, которое объединяет(инкапсулирует) данные и методы. И эти методы могут манипулировать этими данными,
а также защищает и то, и другое от внешнего вмешательства или неправильного использования.
То есть: Инкапсуляция - это объединение данных и методов для работы с этими данными в одной упаковке («капсуле»).'
);
INSERT INTO questions (question, answer_id) VALUES ('Что такое инкапсуляция?', 5);

INSERT INTO answers (answer) VALUES (
'Свойство системы, которое позволяет описать новый класс на основе уже существующего с частичной или полностью заимствованной функциональностью.'
);
INSERT INTO questions (question, answer_id) VALUES ('Что такое наследование?', 6);

INSERT INTO answers (answer) VALUES (
'Полиморфизм – это свойство системы использовать объекты с одинаковым интерфейсом без информации о типе и внутренней структуре объекта. Преимуществом полиморфизма является то, что он помогает снижать сложность программ, разрешая использование одного и того же интерфейса для задания единого набора действий. А выбор какого-то конкретного действия, возлагается на компилятор языка программирования, в зависимости от ситуации. Отсюда следует ключевая особенность полиморфизма - использование объекта производного класса, вместо объекта базового (потомки могут изменять родительское поведение, даже если обращение к ним будет производиться по ссылке родительского типа). Полиморфизм бывает динамическим (переопределение) и статическим (перегрузка). Полиморфная переменная, это переменная, которая может принимать значения разных типов, а полиморфная функция, это функция у которой хотя бы один аргумент является полиморфной переменной. Выделяют два вида полиморфных функций: -ad hoc, функция ведет себя по разному для разных типов аргументов (например, функция draw() — рисует по разному фигуры разных типов); -параметрическая функция ведет себя одинаково для аргументов разных типов (например, функция add() — одинаково кладет в контейнер элементы разных типов).'
);
INSERT INTO questions (question, answer_id) VALUES ('Что такое полиморфизм?', 7);

INSERT INTO answers (answer) VALUES (
'Ассоциация - обозначает связь между обьектами. Например, игрок играет в определенной команде.
"Ассоциация означает, что объекты двух классов могут ссылаться один на другой, иметь некоторую связь между друг другом. "
"Например: Менеджер может выписать Счет.
"Соответственно возникает ассоциация между Менеджером и Счетом.
"Еще пример — Преподаватель и Студент — т.е. какой-то Студент учится у какого-то Преподавателя.
"Ассоциация и есть описание связи между двумя объектами. Студент учится у Преподавателя. Идея достаточно простая — два объекта могут быть
связаны между собой и это надо как-то описать.');
INSERT INTO questions (question, answer_id) VALUES ('Что такое ассоциация?', 8);

INSERT INTO answers (answer) VALUES (
'Композиция — еще более жесткое отношение, когда объект не только является частью другого объекта, но и вообще не может принадлежат еще кому-то.
Например Машина и Двигатель. Хотя двигатель может быть и без машины,
но он вряд ли сможет быть в двух или трех машинах одновременно.
В отличии от студента, который может входить и в другие группы тоже.
Например, класс автомобиля содержит объект класса электрического двигателя:

public class ElectricEngine{ }
public class Car {
ElectricEngine engine;
public Car()
engine = new ElectricEngine();

При этом класс автомобиля полностью управляет жизненным циклом объекта двигателя. При уничтожении объекта автомобиля в
области памяти вместе с ним будет уничтожен и объект двигателя. И в этом плане объект автомобиля является главным,
а объект двигателя - зависимой.'
);
INSERT INTO questions (question, answer_id) VALUES ('Что такое композиция?', 9);

INSERT INTO answers (answer) VALUES (
'Агрегация определяет отношение Has a (англ. Имеет), но связь слабее чем в композиции, т.к. обьекты равноправны.'
);
INSERT INTO questions (question, answer_id) VALUES ('Что такое агрегация?', 10);

INSERT INTO answers (answer) VALUES (
'Связывание есть наличие связи между вызываемым методом программы и написанным кодом.
"Ранее свзязывание означает что - если метод известен компилятору, то происходит ранее связывание на этапе компиляции (early binding),
также называют статическим связыванием.
Позднее связывание (late binding) означает что - вызов метода возможен только во время выполнения, т.к. у компилятора
нет информации, чтобы проверить корректность такого вызова. В java это возможно при помощи рефлексии.'
);
INSERT INTO questions (question, answer_id) VALUES ('Расскажите про раннее и позднее связывание.', 11);

INSERT INTO answers (answer) VALUES (
'SOLID — это акроним, образованный из заглавных букв первых пяти принципов ООП и проектирования.
* S(Single Responsibility Principle) - принцип единственной ответственности - каждый класс выполняет лишь одну задачу.
Легкая модификация в будущем, простое тестирование, класс не имеет зависимостей на другие классы.
* O(Open Closed Principle) - принцип открытости/закрытости - программные сущности открыты для расширения и закрыты для
модификации.
Чтобы не сломать логику в классе-родителе, мы унаследуемся от него и реализуем что-то своё, и используем свой класс.
* L(Liskov’s Substitution Principle) - принцип подстановки Барбары Лисков -  объекты в программе можно заменить их
наследниками без изменения свойств программы.
* I(Interface Segregation Principle) - принцип разделения интерфейса - много специализированных интерфейсов лучше, чем
один общий.
* D(Dependency Inversion Principle) - принцип инверсии зависимостей - зависимость на абстракциях.
Модули верхних уровней не должны зависеть от модулей нижних уровней. Оба типа модулей должны зависеть от абстракций.
Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.
Эти принципы могут использоваться при создании интерфейсов и их реализаций. Например: терминал оплаты(абстракция) и разные
карты оплаты.'
);
INSERT INTO questions (question, answer_id) VALUES ('Принципы SOLID.', 12);

INSERT INTO answers (answer) VALUES (
'Написано однажды - работает везде!
Данная идея основывается в написании одного кода, который будет работать на любой платформе.'
);
INSERT INTO questions (question, answer_id) VALUES ('Какая основная идея языка?', 13);

INSERT INTO answers (answer) VALUES (
'Кроссплатформенность была достигнута за счёт создания виртуальной машина Java.
Java Virtual Machine или JVM - это программа, являющаяся прослойкой между операционной системой и Java программой.
В среде виртуальной машины выполняются коды Java программ. Сама JVM реализована для разных ОС.
И поэтому байт-код для JVM может исполняться везде где установлена JVM,
и его не нужно перекомпилировать под каждую из платформ.'
);
INSERT INTO questions (question, answer_id) VALUES ('За счет чего обеспечивается кроссплатформенность?', 14);

INSERT INTO answers (answer) VALUES (
'Объектно-ориентированное программирование: Структура данных становится объектом, которым можно управлять для создания
отношений между различными объектами.
- Язык высокого уровня с простым синтаксисом и плавной кривой обучения: Синтаксис Java основан на C ++, поэтому Java похожа на C.
Тем не менее, синтаксис Java проще, что позволяет новичкам быстрее учиться и эффективнее использовать код для достижения
конкретных результатов.
- Стандарт для корпоративных вычислительных систем
Корпоративные приложения — главное преимущество Java с 90-х годов, когда организации начали искать надежные инструменты
программирования, вместо языка C.
- Безопасность: Благодаря отсутсвию указателей и Security Manager (политика безопасности,
в которой можно указать правила доступа, позволяет запускать приложения Java в \"песочнице\").
- Независимость от платформы: Можно создать Java-приложение на Windows, скомпилировать его в байт-код и запустить его на любой
другой платформе, поддерживающей виртуальную машину Java (JVM). Таким образом,
JVM служит уровнем абстракции между кодом и оборудованием.
- Язык для распределенного программирования и комфортной удаленной совместной работы
Специфическая для Java методология распределенных вычислений называется Remote Method Invocation (RMI).
RMI позволяет использовать все преимущества Java: безопасность, независимость от платформы и объектно-ориентированное
программирование для распределенных вычислений.
Кроме того, Java также поддерживает программирование сокетов и методологию распределения CORBA для обмена объектами между
программами, написанными на разных языках.
- Автоматическое управление памятью:
Разработчикам Java не нужно вручную писать код для управления памятью благодаря
автоматическому управлению памятью (AMM).
- Многопоточность:
Поток — наименьшая единица обработки в программировании. Чтобы максимально эффективно использовать время процессора, Java позволяет
запускать потоки одновременно, что называется многопоточностью.
- Стабильность и сообщество:
Сообщество разработчиков Java не имеет себе равных. Около 45% респондентов опроса StackOverflow 2018 используют Java.'
);
INSERT INTO questions (question, answer_id) VALUES ('Какие преимущества у java?', 15);

INSERT INTO answers (answer) VALUES (
'Платное коммерческое использование (с 2019).
Низкая производительность из-за компиляции и абстракции с помощью виртуальной машины, а также приложение очистки памяти.
- Не развитые инструменты по созданию GUI приложений на чистой java.
- Многословный код
Java — это более легкая версия неприступного C ++, которая вынуждает программистов прописывать свои действия словами из
английского языка. Это делает язык более понятным для неспециалистов, но менее компактным.'
);
INSERT INTO questions (question, answer_id) VALUES ('Какие недостатки у Java?', 16);

INSERT INTO answers (answer) VALUES (
'JDK (Java Development Kit) - включает JRE и набор инструментов разработчика приложений на языке Java:
* компилятор Java (javac).
* стандартные библиотеки классов java.
* примеры.
* документацию.
* различные утилиты.'
);
INSERT INTO questions (question, answer_id) VALUES ('Что такое JDK? Что в него входит?', 17);

INSERT INTO answers (answer) VALUES (
'JRE (java Runtime Environment) - минимально-необходимая реализация виртуальной машины для исполнения Java-приложений.
Состоит из JVM, ClassLoader(загрузчик классов, который динамически загружает классы Java в JVM) и стандартного набора
библиотек и классов Java.'
);
INSERT INTO questions (question, answer_id) VALUES ('Что такое JRE? что в него входит?', 18);

INSERT INTO answers (answer) VALUES (
'JVM (Java Virtual Machine) - виртуальная машина Java, которая исполняет байт-код Java, (предварительно созданный из
 кода JIT компилятором) с помощью встроенного интерпретатора байткода
 HotSpot представляет собой реализацию концепции JVM.'
);
INSERT INTO questions (question, answer_id) VALUES ('Что такое JVM?', 19);

INSERT INTO answers (answer) VALUES (
'Байт-код Java — набор инструкций, скомпилированный компилятором, исполняемый JVM.'
);
INSERT INTO questions (question, answer_id) VALUES ('Что такое byte code?', 20);

INSERT INTO answers (answer) VALUES (
'Используется для передачи в JVM скомпилированного байт-кода, хранится в файлах с расширением .class.
При запуске JVM, используются три загрузчика классов:
* Bootstrap ClassLoader - базовый загрузчик
- загружает классы платформы JDK из архива rt.jar.
* Extension ClassLoader - загрузчик расширений
- загружает классы расширений, которые по умолчанию находятся в каталоге jre/lib/ext.
* AppClassLoader - системный загрузчик
- загружает классы приложения, определенные в CLASSPATH.
ClassLoader выполняет три основных действия в строгом порядке:
• Загрузка: находит и импортирует двоичные данные для типа.
• Связывание: выполняет проверку, подготовку и (необязательно) разрешение.
- Проверка: обеспечивает правильность импортируемого типа.
- Подготовка: выделяет память для переменных класса и инициализация памяти значениями по умолчанию.
- Разрешение: преобразует символические ссылки из типа в прямые ссылки.
• Инициализация: вызывает код Java, который инициализирует переменные класса их правильными начальными значениями.
Каждый загрузчик хранит указатель на родительский, чтобы суметь передать загрузку если сам будет не в состоянии этого сделать.'
);
INSERT INTO questions (question, answer_id) VALUES ('Что такое загрузчик классов (classloader)?', 21);

INSERT INTO answers (answer) VALUES (
'JIT (Just-in-time compilation) - компиляция на лету или динамическая компиляция. Это такая технология увеличения
 производительности программных систем,
 путем компиляции байт-кода в машинный код, прямо во время работы программы.
 В основном - отвечает за оптимизацию производительности приложений во время их выполнения.'
);
INSERT INTO questions (question, answer_id) VALUES ('Что такое JIT?', 22);

INSERT INTO answers (answer) VALUES (
'Сборщик мусора выполняет две задачи:
* Поиск мусора и очистку мусора.
Для обнаружения мусора есть два подхода:
- Учет(Подсчет) ссылок (Reference counting);
Это означает что - если обьект не имеет ссылок, он считается мусором.
Проблема заключается в том, что при таком подходе нет возможности выявить циклические ссылки, т.е. когда два обьекта не имеют
внешних ссылок, но зато  ссылаются друг на друга. В следствии чего происходит -> утечка памяти.
- Трассировка (Tracing). (используется в HotSpot 6)  >> HotSpot - это одна из реализаций JVM.
Это означает что - до обьекта можно добраться из Корневых точек (GC root).
А до чего нельзя будет добраться - будет считаться мусором.
>> Корневые точки - это объекты или ссылки, которые создаются непосредственно в выполняемом коде.
И всё, что доступно из «живого»(используемого) объекта, также является «живым». (т.е., как я понял - живой объект это объект
на который имеется ссылка).
Типы корневых точек (GC Roots) java приложения:
- объекты в статических полях классов
- объекты, доступные из стека потоков
- объекты из JNI(java native interface) ссылок в native методах.
Существует 4 типа корневых точки:
• Локальные переменные и параметры методов;
• Потоки;
• Статические переменные;
• Ссылки из JNI.
Самое простое java приложение будет иметь следующие корневые точки:
• Локальные переменные внутри метода main(), и параметры метода main();
• Поток который выполняет метод main();
• Статические переменные класса, внутри которого находится метод main().
Процессы сборки мусора разделяются на несколько видов:
* minor GC (малая) - частая и быстрая сборка мусора. Работает только с областью памяти \"Young generation\".
- приложение приостанавливается на начало сборки мусора (такие остановки называются stop-the-world);
- «живые» объекты из Eden перемещаются в область памяти «To Space» (или как я понял в Survival Space);
- «живые» объекты из «From Space» перемещаются в «To Space» или в «Old generation», если они достаточно «старые»;
- Eden и «From Space» очищаются от мусора;
- «To Space» и «From Space» меняются местами;
- приложение возобновляет работу.
* major GC (старшая) - редкий и более длительный, затрагивает объекты старшего поколения.
В принцип работы «major GC» добавляется специальная процедура «уплотнения», позволяющая более эффективно использовать память.
И в этой процедуре живые объекты перемещаются в начало. Таким образом, мусор остается в конце памяти.
* full GC (полная) -  полный сборщик мусора сначала запускает Minor, а затем Major (хотя порядок может быть изменен, если
старое поколение заполнено, и в этом случае он освобождается первым,
чтобы позволить ему получать объекты от молодого поколения).
>> По информации из сайта JavaRush. Куча, где хранятся все созданные объекты, делится на несколько частей:
>> Yung Generation и Old Generation.
>> Yung Generation - делится на Eden(Райский сад) и Survival Space(Место для выжиыших). Survival Space делится на 5 разделов
для каждого поколения.'
);
INSERT INTO questions (question, answer_id) VALUES ('Что такое сборщик мусора? (Garbage collector)', 23);

INSERT INTO answers (answer) VALUES (
'Память процесса делится на Stack (стек) и Heap (куча) :
* Stack содержит staсk-frame-ы, которые делятся на три части: параметры метода, указатель на предыдущий фрейм и локальные переменные.
* Структура Heap будет зависеть от выбранного сборщика мусора.
- Размер памяти стека, меньше памяти кучи. Стековая память быстрее памяти кучи.
- Heap - используется всем приложением, Stack - одним потоком исполняемой программы.
- Обьекты в куче доступны из любого места программы, стековая память не доступна для других потоков.
- Новый обьект создается в heap, в stack размещается ссылка на него. В стеке обычно размещаются локальные переменные
примитивных типов.
- Если память стека закончилась JRE вызовет исключение StackOverflowError, если куча заполнена OutOfMemoryError.
- В куче есть ссылки между объектами и их классами. На этом основана рефлексия.
Обе области хранятся в RAM.
С помощью опций Xms и Xmx можно настроить начальный и максимально допустимый размер кучи соответственно.
Также существуют опции для настройки величины стека.'
);
INSERT INTO questions (question, answer_id) VALUES ('Что такое Heap и Stack память в Java? Чем они отличаются?', 24);

INSERT INTO answers (answer) VALUES (
'Целочисленные, Вещественные, Логические и Строковые.
* byte   = 8 бит  , от -128 до 127
* short  = 16 бит , от -32768 до 32767
* int    = 32 бит , от -2147483648 до 2147483647
* long   = 64 бит , от -9223372036854775808L до 9223372036854775807L
* float  = 32 бит , от 1.4e-45f до 3.4e+38f
* double = 64 бит , от 4.9e-324 до 1.7e+308
* char   = 16 бит , от 0 до 65536
* boolean = 8 бит в массиве, и 32 бита в остальных случаях.'
);
INSERT INTO questions (question, answer_id) VALUES ('Какие примитивные типы данных есть в Java?', 25);

INSERT INTO answers (answer) VALUES (
'16-разрядное беззнаковое целое, представляющее собой символ UTF-16 (буквы и цифры)'
);
INSERT INTO questions (question, answer_id) VALUES ('Что такое char?', 26);

INSERT INTO answers (answer) VALUES (
'Это зависит от реализации JVM.
В стандартной реализации Sun JVM и Oracle HotSpot JVM тип boolean занимает 4 байта (32 бита), как и тип int.
Однако, в определенных версия JVM имеются реализации, где в массиве boolean каждое значение занимает по 1-му биту.'
);
INSERT INTO questions (question, answer_id) VALUES ('Сколько памяти занимает boolean?', 27);

INSERT INTO answers (answer) VALUES (
'Обертка — это специальный класс, который хранит внутри себя значение примитива(объекты классов-оберток являются неизменяемыми (Immutable)).
Нужны для реализации дженериков.
Классы-обёртки были придуманы для того, чтобы иметь возможность оперировать с простыми числами (и boolean) как с объектами.'
);
INSERT INTO questions (question, answer_id) VALUES ('Что такое классы-обертки?', 28);

INSERT INTO answers (answer) VALUES (
'- Автоупаковка - это преобразование примитивных типов в эквивалентные объекты.
 - Автораспаковка - это преобразование объектов в соответствующие им примитивные типы.
Для присваивания ссылок-примитивов объектам их классов-оберток (и наоборот) не требуется ничего делать, все происходит автоматически.'
);
INSERT INTO questions (question, answer_id) VALUES ('Что такое автоупаковка и автораспаковка?', 29);

INSERT INTO answers (answer) VALUES (
'Неявное приведение - автоматическое расширение типа переменной от меньшего к большему.
 Явное приведение - явное сужение от большего к меньшему. Необходимо явно указать сужаемый тип.
В случае с объектами мы можем делать неявное(автоматическое) приведение от наследника к родителю, но не наоборот, иначе получим ClassCastException.'
);
INSERT INTO questions (question, answer_id) VALUES ('Что такое явное и неявное приведение типов? В каких случаях в java нужно использовать явное приведение?', 30);

INSERT INTO answers (answer) VALUES (
'В Java есть пул(pool) целых чисел в промежутке [-128;127], так как это самый часто вречающийся диапазон.
Т.е. если мы создаем Integer в этом промежутке, то вместо того, чтобы каждый раз создавать новый объект, JVM берет их из пула.'
);
INSERT INTO questions (question, answer_id) VALUES ('Что такое пул интов?', 31);

INSERT INTO answers (answer) VALUES (
'Класс String в Java - является неизменяемым из-за модификатора final и отсутствия сеттера. Это нужно для реализации пула стрингов.
При редактировании будет создаваться новая строка. При копировании новая строка не создается, а создается ссылка на существующую строку.'
);
INSERT INTO questions (question, answer_id) VALUES ('Какие нюансы у строк в Java?', 32);

INSERT INTO answers (answer) VALUES (
'Пул строк это - область памяти где хранятся обьекты строк.
При создании в пуле идет поиск строки:

- если не находит - то создается строка, и возращается ссылка.
- если находит - то возращает ссылку найденной строки.
При этом использование оператора new заставляет класс String создать новый объект, даже если такая строка уже есть в пуле.
После этого можем использовать метод intern(), чтобы поместить этот объект в пул строк.

Пул строк и Integer хранятся в Heap-е, но ссылки на объекты хранятся в stack.'
);
INSERT INTO questions (question, answer_id) VALUES ('Что такое пул строк?', 33);

INSERT INTO answers (answer) VALUES (
'- Т.к. строка неизменяемый класс, то будет большое потребление ресурсов при редактировании.
- Т.к. каждую итерацию при редактировании будет создаваться новый обьект строки.
Рекомендуется использовать StringBuilder или StringBuffer.       '
);
INSERT INTO questions (question, answer_id) VALUES ('Почему не рекомендуется изменять строки в цикле? Что рекомендуется использовать?', 34);

INSERT INTO answers (answer) VALUES (
'1. Пул строк.
Так как строки в Java хранятся в пуле строк, то ваш пароль в виде обычного текста будет доступен в памяти, пока сборщик мусора не очистит её.
И поскольку String используются в String pool для повторного использования, существует довольно высокая вероятность того, что пароль останется в памяти надолго, что совсем не безопасно.
2. Рекомендации авторов.
Java сама по себе рекомендует использовать метод getPassword () из класса JPasswordField, который возвращает char [].
3. Случайная печать в логах.
С типом String всегда существует опасность того, что текст, хранящийся в строке будет напечатан в файле логов или в консоли.
В то же время в случае использования Array, вы не будете печатать содержимое массива, а только его расположение в памяти.'
);
INSERT INTO questions (question, answer_id) VALUES ('Почему строки не рекомендуется использовать для хранения паролей?', 35);

INSERT INTO answers (answer) VALUES (
'1. Для возможности реализации строкового пула (String pool).
Виртуальная машина имеет возможность сохранить много места в памяти (heap space) т.к. разные строковые переменные указывают на одну переменную в пуле.
При изменяемости строк было бы невозможно реализовать интернирование, поскольку если какая-либо переменная изменит значение, это отразится также и на остальных переменных, ссылающихся на эту строку.
2. Безопасность.
Изменяемость строк несло бы в себе потенциальную угрозу безопасности приложения. Поскольку в Java строки используются для передачи параметров для авторизации, открытия файлов и т.д. — неизменяемость позволяет избежать проблем с доступом.
3. Для многопоточности. Неизменяемые строки потокобезопасны.
Так как строка неизменяемая то, она безопасна для много поточности и один экземпляр строки может быть совместно использован различными потоками. Это позволяет избежать синхронизации для потокобезопасности. Таким образом, строки в Java полностью потокобезопасны.
4. Ключ для HashMap.
Поскольку строка неизменная, её hashcode кэшируется в момент создания и нет никакой необходимости рассчитывать его снова. Это делает строку отличным кандидатом для ключа в Map и его обработка будет быстрее, чем других ключей HashMap. Поэтому строка наиболее часто используется в качестве ключа HashMap.

В итоге:
- можно передавать строку между потоками не опасаясь, что она будет изменена.
- отсутствуют проблемы с синхронизацией потоков.
- отсутствие проблем с  утечкой памяти.
- отсутствие проблем с доступом и безопасностью при использовании строк для передачи параметров авторизации, открытия файлов и т.д.
- кэширование hashcode.
- экономия памяти при использовании пула строк для хранения повторяющихся строк.'
);
INSERT INTO questions (question, answer_id) VALUES ('Почему String неизменяемый и финализированный класс?', 36);

INSERT INTO answers (answer) VALUES (
'Поскольку строки неизменны, их хэшкод кэшируется в момент создания, и не требует повторного пересчета.'
);
INSERT INTO questions (question, answer_id) VALUES ('Почему строка является популярным ключом в HashMap в Java?', 37);

INSERT INTO answers (answer) VALUES (
'Помещает строку в pool строк. (Например, если мы создали новую строку с помощью оператора new).'
);
INSERT INTO questions (question, answer_id) VALUES ('Что делает метод intern() в классе String?', 38);

INSERT INTO answers (answer) VALUES (
'Да, начиная с Java 7 в операторе switch можно использовать строки, ранние версии Java не поддерживают этого.
При этом:
- участвующие строки чувствительны к регистру;
- использование строк в конструкции switch делает код читабельнее, убирая множественные цепи условий if-else
- оператор switch использует метод String.equals() для сравнения полученного значения со значениями case, поэтому добавьте проверку на NULL во избежание NullPointerException.'
);
INSERT INTO questions (question, answer_id) VALUES ('Можно ли использовать строки в конструкции switch?', 39);

INSERT INTO answers (answer) VALUES (
'- String - неизменяемый, потокобезопасный.
- StringBuffer - изменяемый, потокобезопасный.
- StringBuilder - изменяемый, потоконебезопасный.'
);
INSERT INTO questions (question, answer_id) VALUES ('Какая основная разница между String, StringBuffer, StringBuilder?', 40);

INSERT INTO answers (answer) VALUES (
'Многомерные массивы в их классическом понимании в java не существуют.
 Многомерный массив всегда прямоугольный и неразрывен в памяти.
А то, что в java считается мнoгомерным - в других языках ещё называют "зубчатым массивом" или массивом массивов.'
);
INSERT INTO questions (question, answer_id) VALUES ('Существуют ли в java многомерные массивы?', 41);

INSERT INTO answers (answer) VALUES (
'- byte    = 0
- short   = 0
- int     = 0
- long    = 0L
- float   = 0.0f
- double  = 0.0d
- char    = \u0000
- boolean = false
- Обьекты = null
Локальные (в методе) переменные не имеют значений по умолчанию, их имеют только поля класса.
Не static-поле класса будет инициализировано после того, как будет создан объект этого класса.
А  static-поле будет инициализировано тогда, когда класс будет загружен виртуальной Java машиной. '
);
INSERT INTO questions (question, answer_id) VALUES ('Какими значениями инициируются переменные по умолчанию?', 42);

INSERT INTO answers (answer) VALUES (
'- Это имя метода плюс параметры (порядок параметров имеет значение из-за множественной передачи данных через троеточие, которое должно располагаться последним).
В сигнатуру метода не входит возвращаемое значение, и не входит бросаемые им исключения.
А сигнатура метода в сочетании с типом возвращаемого значения и бросаемыми исключениями называется контрактом метода.'
);
INSERT INTO questions (question, answer_id) VALUES ('Что такое сигнатура метода?', 43);

INSERT INTO answers (answer) VALUES (
'Является, как правило, точкой входа в программу и вызывается JVM.
Как только заканчивается выполнение метода main(), так сразу же завершается работа самой программы.
static - чтобы JVM смогла загрузить его во время компиляции.
public static void и сигнатура - это обязательное декларирование.
Мэйнов может быть много и может не быть вообще.
Также может быть перегружен.'
);
INSERT INTO questions (question, answer_id) VALUES ('Расскажите про метод main.', 44);

INSERT INTO answers (answer) VALUES (
'- Java передает параметры по значению. Всегда.
С примитивами, мы получаем копию содержимого. Со ссылками мы тоже получаем копию ссылки.'
);
INSERT INTO questions (question, answer_id) VALUES ('Каким образом переменные передаются в методы, по значению или по ссылке?', 45);

INSERT INTO answers (answer) VALUES (
'1. Вложенные(Nested) классы – нестатические классы внутри внешнего класса.
2. Вложенные(Nested) статические классы – статические классы внутри внешнего класса.
3. Локальные классы Java – классы внутри методов. Есть разница между локальным и внутреним.
4. Анонимные Java классы – классы, которые создаются на ходу. Анонимные классы доступно.
5. Final, abstract, enum - классы.

К классам верхнего уровня модификатор static неприменим. '
);
INSERT INTO questions (question, answer_id) VALUES ('Какие виды классов есть в java?', 46);

INSERT INTO answers (answer) VALUES (
'- Вложенные классы нужны для обслуживания внешних классов.
1. Статические вложенные классы (Static nested classes).
- Есть возможность обращения к внутренним статическим полям и методам класса обертки.
2. Вложенные классы.
- Есть возможность обращения к внутренним полям и методам класса обертки.
- Не может иметь статических объявлений.
- Внутри такого класса нельзя объявить перечисления.
- Если нужно явно получить this внешнего класса — OuterClass.this;
3. Локальный класс.
- Видны только в пределах блока, в котором объявлены.
- Не могут быть объявлены как private/public/protected или static (по этой причине интерфейсы нельзя объявить локально).
- Не могут иметь внутри себя статических объявлений (полей, методов, классов), но могут иметь константы (static final).
-Имеют доступ к полям и методам обрамляющего класса.
- Можно обращаться к локальным переменным и параметрам метода, если они объявлены с модификатором final или являются effectively final.
4. Анонимные классы.
- Локальный класс без имени.'
);
INSERT INTO questions (question, answer_id) VALUES ('Расскажите про вложенные классы. В каких случаях они применяются?', 47);

INSERT INTO answers (answer) VALUES (
'Данные классы объявляются внутри других методов. Они обладают всеми свойствами нестатического вложенного класса, но только создавать их экземпляры можно только внутри метода.
Особенности:
- Локальные классы способны работать только с final переменными метода.
- С 8+ версий Java можно использовать не final переменные в локальных классах, но только при условии, что они не будут изменяться.
- Локальные классы нельзя объявлять с модификаторами доступа.
- Локальные классы обладают доступом к переменным метода.
- Может быть создан внутри блоков инициализации.'
);
INSERT INTO questions (question, answer_id) VALUES ('Что такое «локальный класс»? Каковы его особенности?', 48);

INSERT INTO answers (answer) VALUES (
'- Это вложенный локальный класс без имени, который разрешено декларировать в любом месте обрамляющего класса, разрешающем размещение выражений.
Создание экземпляра анонимного класса происходит одновременно с его объявлением.
В зависимости от местоположения анонимный класс может вести себя как статический либо как нестатический вложенный класс.

Анонимные классы имеют несколько ограничений:
- Их использование разрешено только в одном месте программы - месте его создания;
- Применение возможно только в том случае, если после порождения экземпляра нет необходимости на него ссылаться;
- Реализует лишь методы своего интерфейса или суперкласса, т.е. не может объявлять новых методов, так как для доступа к ним нет поименованного типа.
- Анонимные классы обычно применяются для:

* создания объекта функции (function object), например реализация интерфейса Comparator;
* создания объекта процесса (process object), такого как экземпляры классов Thread, Runnable и подобных;
* в статическом методе генерации;
* инициализации открытого статического поля final, которое соответствует сложному перечислению типов, когда для каждого экземпляра в перечислении требуется отдельный подкласс.

- Анонимные классы всегда являются конечными классами.
- Каждое объявление анонимного класса уникально.
- Видны только внутри того метода, в котором определены.

В документации Oracle приведена хорошая рекомендация: «Применяйте анонимные классы, если вам нужен локальный класс для одноразового использования». '
);
INSERT INTO questions (question, answer_id) VALUES ('Что такое «анонимные классы»? Где они применяются?', 49);

INSERT INTO answers (answer) VALUES (
'- Статический вложенный класс имеет прямой доступ только к статическим полям обрамляющего класса.
- Простой вложенный класс, может обратиться к любому полю внешнего класса напрямую.
В случае, если у вложенного класса уже существует поле с таким же литералом, то обращаться к внешнему полю следует через имя внешнего класса.
Например: Outer.this.field.'
);
INSERT INTO questions (question, answer_id) VALUES ('Каким образом из вложенного класса получить доступ к полю внешнего класса?', 50);

INSERT INTO answers (answer) VALUES (
'- Перечисления(Enum) - это набор логически связанных констант.
Перечисление фактически представляет новый класс, поэтому мы можем определить переменную данного типа и использовать ее.
Перечисления, как и обычные классы, могут определять конструкторы, поля и методы.
Следует отметить, что конструктор по умолчанию приватный.
Также можно определять методы для отдельных констант.
Методы:
- ordinal() возвращает порядковый номер определенной константы (нумерация начинается с 0).
- values() возвращает массив всех констант перечисления.
Еnum имеет ряд преимуществ при использовании в сравнении с static final int.
Главным отличием является то что используя enum вы можете проверить тип данных.
Недостатки:
- К ним не применимы операторы >, <, >=, <=
- Еnum также требует больше памяти для хранения чем обычная константа.
Нужны для ограничения области допустимых значений: например, времена года, дни недели.'
);
INSERT INTO questions (question, answer_id) VALUES ('Что такое перечисления (enum)?', 51);

INSERT INTO answers (answer) VALUES (
'- В Java нет поддержки множественного наследования классов.
Предположим, что SuperClass — это абстрактный класс, описывающий некоторый метод, а классы ClassA и ClassB — обычные классы наследники SuperClass,
а класс ClassC наследуется от ClassA и ClassB одновременно.
Вызов метода родительского класса приведет к неопределенности, так как компилятор не знает о том, метод какого именно суперкласса должен быть вызван.
Это и есть основная причина, почему в Java нет поддержки множественного наследования классов.

>> В Java множественное наследование не поддерживается в классах, но оно поддерживается в интерфейсах. И один интерфейс может расширять множество других >> интерфейсов.

1. Классы всегда побеждают: Определенный в классе / суперклассе метод всегда имеет высший приоритет перед дефолтными методами интерфейсов.
2. Если не срабатывает правило 1, то побеждают саб-интерфейсы (more specific). Т.е. если интерфейс B наследует A, и у обоих есть методы с одинаковой сигнатурой, то побеждает B.
3. Если оба правила не работают, то класс, наследующий конфликтующие интерфейсы, должен явно через super определить, какой именно метод вызвать, иначе компилятор будет сильно материться.'
);
INSERT INTO questions (question, answer_id) VALUES ('Как проблема ромбовидного наследования решена в java?', 52);

INSERT INTO answers (answer) VALUES (
'- Если у какого-либо класса не определить конструктор, то компилятор сгенерирует конструктор без аргументов - так называемый «конструктор по умолчанию».

Если у класса уже определен какой-либо конструктор, то конструктор по умолчанию создаваться не будет и, если он необходим, его нужно описывать явно.

>> А зачем нужен этот конструктор по умолчанию и без параметров?
>> Создавая объект посредством конструктора без параметра, вы просто инициализируете его поля и выделяете память под этот объект. То-есть в памяти у вас появится ссылка на этот объект, но о нем ничего пока не известно.'
);
INSERT INTO questions (question, answer_id) VALUES ('Что такое конструктор по умолчанию?', 53);

INSERT INTO answers (answer) VALUES (
'- Да, могут. Приватный конструктор запрещает создание экземпляра класса вне методов самого класса.
Нужен для реализации паттернов, например singleton.'
);
INSERT INTO questions (question, answer_id) VALUES ('Могут ли быть приватные конструкторы? Для чего они нужны?', 54);

INSERT INTO answers (answer) VALUES (
'- При запуске JVM, используются три загрузчика классов:
* Bootstrap ClassLoader - главный загрузчик
 - загружает платформенные классы JDK из архива rt.jar.
* Extension ClassLoader - загрузчик расширений
- загружает классы расширений, которые по умолчанию находятся в каталоге jre/lib/ext.
* AppClassLoader - системный загрузчик
 - загружает классы приложения, определенные в CLASSPATH.

Динамическая загрузка происходит "на лету" в ходе выполнения программы с помощью статического метода класса Class.forName(имя класса).

Для чего нужна динамическая загрузка?
- Например мы не знаем какой класс нам понадобится и принимаем решение в ходе выполнения программы передавая имя класса в статический метод forName().'
);
INSERT INTO questions (question, answer_id) VALUES ('Расскажите про классы-загрузчики и про динамическую загрузку классов.', 55);

INSERT INTO answers (answer) VALUES (
'- У конструктора по умолчанию отсутствуют какие-либо аргументы.
- Конструктор копирования принимает в качестве аргумента уже существующий объект класса для последующего создания его клона.
- Конструктор с параметрами имеет в своей сигнатуре аргументы (обычно необходимые для инициализации полей класса).'
);
INSERT INTO questions (question, answer_id) VALUES ('Чем отличаются конструкторы по-умолчанию, конструктор копирования и конструктор с параметрами?', 56);

INSERT INTO answers (answer) VALUES (
'- Private – доступ к компоненту только из этого класса, в котором объявлен.
- Default – Переменная или метод будут доступны для любого другого класса в том же пакете.
- Protected – Поля protected доступны всем классам внутри пакета, а также всем классам-наследникам вне пакета.
- Public – доступ к компоненту из экземпляра любого класса и любого пакета.

Класс может быть объявлен с модификатором public и default. // Хотя я пробовал объявлять класс дефолтным - компилятор ругается.'
);
INSERT INTO questions (question, answer_id) VALUES ('Какие модификаторы доступа есть в Java? Какие применимы к классам?', 57);

INSERT INTO answers (answer) VALUES (
'- Модификатор static в Java напрямую связан с классом.
Если поле статично, значит оно принадлежит классу, если метод статичный — аналогично: он принадлежит классу.
Исходя из этого, можно обращаться к статическому методу или полю, используя имя класса.
Например, если поле count статично в классе Counter, значит, вы можете обратиться к переменной запросом вида: Counter.count. '
);
INSERT INTO questions (question, answer_id) VALUES ('Что означает модификатор static?', 58);

INSERT INTO answers (answer) VALUES (
'- Нет. Нельзя переопределять статические методы.
Если вы объявите такой же метод в классе-наследнике (subclass), т.е. метод с таким же именем и сигнатурой, вы лишь «спрячете» метод суперкласса  вместо переопределения. Это явление известно как сокрытие методов (hiding methods).
Перегружен - да, может.
Всё работает точно так же как и с обычными методами - 2 статических метода могут иметь одинаковое имя, если количество их параметров или типов различается.'
);
INSERT INTO questions (question, answer_id) VALUES ('Может ли статический метод быть переопределён или перегружен?', 59);

INSERT INTO answers (answer) VALUES (
'- Да. Это будут просто два разных метода для программы. Статический будет доступен по имени класса.'
);
INSERT INTO questions (question, answer_id) VALUES ('Могут ли нестатические методы перегрузить статические?', 60);

INSERT INTO answers (answer) VALUES (
'- Сузить нельзя. При переопределении метода нельзя сузить модификатор доступа к методу (например, с public до private), НО МОЖНО РАСШИРИТЬ.
- Изменить тип возвращаемого значения нельзя, но можно сузить возвращаемое значение, но только если они совместимы.
Например, если метод возвращает объект класса, а переопределенный метод возвращает объект класса-наследника.'
);
INSERT INTO questions (question, answer_id) VALUES ('Можно ли сузить уровень доступа/тип возвращаемого значения при переопределении метода?', 61);

INSERT INTO answers (answer) VALUES (
'- В сигнатуре(имя + параметры) менять ничего нельзя.
Возможно расширение уровня доступа.
Изменять тип возвращаемого значения при переопределении метода разрешено только в сторону сужения типа (вместо родительского класса - наследника).
Секцию throws метода можно не указывать, но стоит помнить, что она остаётся действительной, если уже определена у метода родительского класса.
Так же, возможно добавлять новые исключения, являющиеся наследниками от уже объявленных или исключения RuntimeException.
Порядок следования таких элементов при переопределении значения не имеет.'
);
INSERT INTO questions (question, answer_id) VALUES ('Что можно изменить в сигнатуре метода при переопределении? Можно ли менять модификаторы (throws и тп)?', 62);

INSERT INTO answers (answer) VALUES (
'- Класс можно объявить статическим за исключением классов верхнего уровня.
Такие классы известны как «вложенные статические классы» (nested static class). '
);
INSERT INTO questions (question, answer_id) VALUES ('Могут ли классы быть статическими?', 63);

INSERT INTO answers (answer) VALUES (
'- Для класса это означает, что класс не сможет иметь подклассов, т.е. запрещено наследование.
Следует также отметить, что к abstract-классам нельзя применить модификатор final, т.к. это взаимоисключающие понятия.
Для переменных примитивного типа это означает, что однажды присвоенное значение не может быть изменено.
Для ссылочных переменных это означает, что после присвоения объекта, нельзя изменить ссылку на данный объект.
Важно: Ссылку изменить нельзя, но состояние объекта изменять можно.
Т.к. массив – это объект, то final означает, что после присвоения ссылки на объект, уже нельзя ее изменить, но можно изменять состояние объекта.'
);
INSERT INTO questions (question, answer_id) VALUES ('Что означает модификатор final? К чему он может быть применим?', 64);

INSERT INTO answers (answer) VALUES (
'- Абстрактным называется класс, на основе которого не могут создаваться объекты.
Это как обычный класс, но с абстрактными методами.
Нельзя создать объект или экземпляр абстрактного класса.
Наследниками абстрактного класса могут быть другие абстрактные классы.'
);
INSERT INTO questions (question, answer_id) VALUES ('Что такое абстрактные классы? Чем они отличаются от обычных?', 65);

INSERT INTO answers (answer) VALUES (
'- Класс может быть абстрактным без единого абстрактного метода, если у него указан модификатор abstract.'
);
INSERT INTO questions (question, answer_id) VALUES ('Может ли быть абстрактный класс без абстрактных методов?', 66);

INSERT INTO answers (answer) VALUES (
'- Да. Необходимы для наследников.
В абстрактном классе в Java можно объявить и определить конструкторы.
Даже если вы не объявили никакого конструктора, компилятор добавит в абстрактный класс конструктор по умолчанию без аргументов.
Абстрактные конструкторы будут часто использоваться для обеспечения ограничений класса или инвариантов, таких как минимальные поля,
необходимые для настройки класса.'
);
INSERT INTO questions (question, answer_id) VALUES ('Могут ли быть конструкторы у абстрактных классов? Для чего они нужны?', 67);

INSERT INTO answers (answer) VALUES (
'- Интерфейс — это план класса или, можно сказать, набор абстрактных методов и статических констант.
В интерфейсе каждый метод является открытым и абстрактным, но не содержит конструктора.
Таким образом, интерфейс в основном представляет собой группу связанных методов с пустыми телами.
Другими словами, интерфейс определяет как элементы будут взаимодействовать между собой.

- методы интерфейса являются публичными (public) и абстрактными (abstract),
- поля — public static final. '
);
INSERT INTO questions (question, answer_id) VALUES ('Что такое интерфейсы? Какие модификаторы по умолчанию имеют поля и методы интерфейсов?', 68);

INSERT INTO answers (answer) VALUES (
'1. Интерфейс описывает только поведение (методы) объекта, а вот состояний (полей) у него нет (кроме public static final),
в то время как у абстрактного класса они могут быть.
2. Мы можем наследовать только один класс, а реализовать интерфейсов — сколько угодно. Интерфейс может наследовать (extends) другой интерфейс/интерфейсы.
3. Абстрактные классы используются, когда есть отношение "is-a", то есть когда класс-наследник расширяет базовый абстрактный класс,
а интерфейсы могут быть реализованы разными классами, вовсе не связанными друг с другом.
4. Абстрактный класс может реализовывать методы; интерфейс может реализовывать дефолтные методы начиная с 8-й версии Java.'
);
INSERT INTO questions (question, answer_id) VALUES ('Чем интерфейсы отличаются от абстрактных классов? В каких случаях следует использовать абстрактный класс, а в каких интерфейс?', 69);

INSERT INTO answers (answer) VALUES (
'- Да, может. Используется ключевое слово extends'
);
INSERT INTO questions (question, answer_id) VALUES ('Может ли один интерфейс наследоваться от другого? От двух других?', 70);

INSERT INTO answers (answer) VALUES (
'- В JDK-8 была добавлена такая функциональность как методы по умолчанию с модификатором default.
И теперь интерфейсы могут иметь их реализацию по умолчанию, которая используется, если класс, реализующий данный интерфейс, не реализует метод.
Это нужно для обратной совместимости.

(Если один или несколько методов добавляются к интерфейсу, все реализации также будут вынуждены их реализовывать. Методы интерфейса по умолчанию являются эффективным способом решения этой проблемы).'
);
INSERT INTO questions (question, answer_id) VALUES ('Что такое дефолтные методы интерфейсов? Для чего они нужны?', 71);

INSERT INTO answers (answer) VALUES (
'- Класс, наследующий конфликтующие интерфейсы, должен явно через кл. слово super определить, какой именно метод вызвать:
 InterfaceB.super.method();'
);
INSERT INTO questions (question, answer_id) VALUES ('Как решается проблема ромбовидного наследования при наследовании интерфейсов при наличии default методов?', 72);

INSERT INTO answers (answer) VALUES (
'1. Статические блоки от первого до последнего предка(от предка до наследника).
2. Попарно динамической блок инициализации и конструктор от первого до последнего предка.'
);
INSERT INTO questions (question, answer_id) VALUES ('Каков порядок вызова конструкторов и блоков инициализации с учётом иерархии классов?', 73);

INSERT INTO answers (answer) VALUES (
'- Инициализация - это когда мы впервые задаем переменной какое-либо значение.
Существуют статические и нестатические блоки инициализации.'
);
INSERT INTO questions (question, answer_id) VALUES ('Зачем нужны и какие бывают блоки инициализации?', 74);

INSERT INTO answers (answer) VALUES (
'- Статические блоки инициализации используются для выполнения кода, который должен выполняться один раз при инициализации класса загрузчиком классов, в момент предшествующий созданию объектов этого класса при помощи конструктора.
Такой блок принадлежит только самому классу.'
);
INSERT INTO questions (question, answer_id) VALUES ('Для чего в Java используются статические блоки инициализации?', 75);

INSERT INTO answers (answer) VALUES (
'- Для нестатических блоков инициализации, если выбрасывание исключения прописано явным образом, требуется, чтобы объявления этих исключений были
перечислены в throws всех конструкторов класса. Иначе будет ошибка компиляции.
- Для статического блока выбрасывание исключения в явном виде, приводит к ошибке компиляции.'
);
INSERT INTO questions (question, answer_id) VALUES ('Что произойдет, если в блоке инициализации возникнет исключительная ситуация?', 76);

INSERT INTO answers (answer) VALUES (
'- Если возникшее исключение - наследник RuntimeException:
* для статических блоков инициализации будет выброшено java.lang.ExceptionInInitializerError;
* для нестатических будет проброшено исключение-источник.
- Если возникшее исключение - наследник Error, то в обоих случаях будет выброшено java.lang.Error.
- Если исключение: java.lang.ThreadDeath - смерть потока. В этом случае никакое исключение выброшено не будет.'
);
INSERT INTO questions (question, answer_id) VALUES ('Какое исключение выбрасывается при возникновении ошибки в блоке инициализации класса?', 77);

INSERT INTO answers (answer) VALUES (
'- Базовый класс для всех остальных объектов в Java. Любой класс наследуется от Object и, соответственно, наследуют его методы.
Все классы являются наследниками суперкласса Object. Это не нужно указывать явно. В результате объект Object может ссылаться на объект любого другого класса.
Рефлексия (от позднелат. reflexio - обращение назад) - это механизм исследования данных о программе во время её выполнения.'
);
INSERT INTO questions (question, answer_id) VALUES ('Что такое класс Object?', 78);

INSERT INTO answers (answer) VALUES (
'- equals() - проверка на равенство двух обьектов.
- hashCode() - изначально случайно число int.
- toString() - представления данного объекта в виде строки.
- getClass() - получение типа данного обьекта.
- clone() -  клонирует объект методом.
- finalize() - deprecated, вызывается GC перед удалением. (нет гарантии что будет вызван).
А так-же для многопоточки:
- wait(): освобождает монитор и переводит вызывающий поток в состояние ожидания до тех пор, пока другой поток не вызовет метод notify().
- notify(): продолжает работу потока, у которого ранее был вызван метод wait().
- notifyAll(): возобновляет работу всех потоков, у которых ранее был вызван метод wait().
- wait(long timeOut) - нить освобождает монитор и «становится на паузу», принимает максимальное время ожидания в миллисекундах.
- wait(long timeOut, int nanos) - нить освобождает монитор и «становится на паузу», принимает максимальное время ожидания в миллисекундах, дополнительное время, в диапазоне наносекунд 0-999999.'
);
INSERT INTO questions (question, answer_id) VALUES ('Какие методы есть у класса Object (перечислить все)? Что они делают?', 79);

INSERT INTO answers (answer) VALUES (
'- Хеш-код — это целочисленный результат работы метода, которому в качестве входного параметра передан объект.
Если более точно, то это битовая строка фиксированной длины, полученная из массива произвольной длины.
Equals - это метод, определенный в Object, который служит для сравнения объектов. При сравнении объектов при помощи == идет сравнение по ссылкам.
При сравнении по equals() идет сравнение по состояниям объектов.
Свойства equals():
• Симметричность: Для двух ссылок, a и b, a.equals(b) тогда и только тогда, когда b.equals(a).
• Рефлексивность: Для любого заданного значения x, выражение x.equals(x) должно возвращать true.
 Для заданного — имеется в виду такого, что x != null.
• Постоянство: Повторный вызов метода equals() должен возвращать одно и тоже значение до тех пор, пока какое-либо значение свойств объекта не будет изменено.
• Транзитивность: Если a.equals(b) и b.equals(c), то тогда a.equals(c).
• Совместимость с hashCode(): Два тождественно равных объекта должны иметь одно и то же значение hashCode().
При переопределении equals() обязательно нужно переопределить метод hashCode(). Равные объекты должны возвращать одинаковые хэш коды.'
);
INSERT INTO questions (question, answer_id) VALUES ('Расскажите про equals и hashcode.', 80);

INSERT INTO answers (answer) VALUES (
'1. Реализация метода Object.equals() сводится к проверке на равенство двух ссылок:
public boolean equals(Object obj) {
	return (this == obj);
}
2. HashCode реализован таким образом, что для одного и того же входного объекта, хеш-код всегда будет одинаковым.
Реализация метода Object.hashCode() описана как native, т.е. написана не на Java.
Непереопределенный hashCode возвращает идентификационный хеш, основанный на состоянии потока, объединённого с xorshift (в OpenJDK8).
А вообще, функция предлагает шесть методов на базе значения переменной hashCode.

0. Случайно сгенерированное число.
1. Функция адреса объекта в памяти.
2. Жёстко запрограммированное значение 1 (используется при тестировании на чувствительность (sensitivity testing)).
3. Последовательность.
4. Адрес объекта в памяти, приведённый к целочисленному значению.
5. Состояние потока, объединённое с xorshift:                        public native int hashCode();

Ситуация, когда у разных объектов одинаковые хеш-коды называется — коллизией.
Вероятность возникновения коллизии зависит от используемого алгоритма генерации хеш-кода.'
);
INSERT INTO questions (question, answer_id) VALUES ('Каким образом реализованы методы hashCode() и equals() в классе Object?', 81);

INSERT INTO answers (answer) VALUES (
'- equals() - сравнение по состоянию, == - по ссылкам.'
);
INSERT INTO questions (question, answer_id) VALUES ('Зачем нужен equals()?', 82);

INSERT INTO answers (answer) VALUES (
'- Нарушится контракт. Классы и методы, которые использовали правила этого контракта могут некорректно работать.
Так для объекта HashMap это может привести к тому, что пара, которая была помещена в Map возможно не будет найдена в ней при обращении к Map, если используется новый экземпляр ключа.'
);
INSERT INTO questions (question, answer_id) VALUES ('Что будет, если переопределить equals() не переопределяя hashCode()? Какие могут возникнуть проблемы?', 83);

INSERT INTO answers (answer) VALUES (
'1. Если два объекта возвращают разные значения hashcode(), то они не могут быть равны.
2. Если equals объектов true, то и хэшкоды должны быть равны.
3. Переопределив equals, всегда переопределять и hashcode.'
);
INSERT INTO questions (question, answer_id) VALUES ('Какой контракт между hashCode() и equals()?', 84);

INSERT INTO answers (answer) VALUES (
'- вычисляет целочисленное значение для конкретного элемента класса, чтобы использовать его для быстрого поиска и доступа к этому элементу в hash-структурах данных, например, HashMap, HashSet и прочих.'
);
INSERT INTO questions (question, answer_id) VALUES ('Для чего нужен метод hashCode()?', 85);

INSERT INTO answers (answer) VALUES (
'- Если хеш-коды разные, то и входные объекты гарантированно разные.
- Если хеш-коды равны, то входные объекты не всегда равны.
При вычислении хэш-кода следует использовать те же поля, которые сравниваются в equals и которые не вычисляются на основе других значений.
- вызов метода hashCode один и более раз над одним и тем же объектом должен возвращать одно и то же хэш-значение, при условии что поля объекта, участвующие в вычислении значения, не изменялись.
- вызов метода hashCode над двумя объектами должен всегда возвращать одно и то же число, если эти объекты равны (вызов метода equals для этих объектов возвращает true).
- вызов метода hashCode над двумя неравными между собой объектами должен возвращать разные хэш-значения. Хотя это требование и не является обязательным, следует учитывать, что его выполнение положительно повлияет на производительность работы хэш-таблиц.'
);
INSERT INTO questions (question, answer_id) VALUES ('Правила переопределения метода hashCode().', 86);

INSERT INTO answers (answer) VALUES (
'- Выбирать поля, которые с большой долью вероятности будут различаться.
Для этого необходимо использовать уникальные, лучше всего примитивные поля, например такие как id, uuid.
При этом нужно следовать правилу, если поля задействованы при вычислении hashCode(), то они должны быть задействованы и при выполнении equals().'
);
INSERT INTO questions (question, answer_id) VALUES ('Есть ли какие-либо рекомендации о том, какие поля следует использовать при подсчете hashCode()?', 87);

INSERT INTO answers (answer) VALUES (
'- Когда у разных объектов одинаковые хеш-коды называется — коллизией.'
);
INSERT INTO questions (question, answer_id) VALUES ('Могут ли у разных объектов быть одинаковые hashCode()?', 88);

INSERT INTO answers (answer) VALUES (
'- В Java множество возможных хэш-кодов ограничено типом int, а множество объектов ничем не ограничено.
Из-за этого, вполне возможна ситуация, что хэш-коды разных объектов могут совпасть.'
);
INSERT INTO questions (question, answer_id) VALUES ('Почему нельзя реализовать hashCode(), который будет гарантированно уникальным для каждого объекта?', 89);

INSERT INTO answers (answer) VALUES (
'- Множитель создает зависимость значения хэш-кода от очередности обработки полей, а это дает гораздо лучшую хэш-функцию.'
);
INSERT INTO questions (question, answer_id) VALUES ('Есть класс Point{int x, y;}. Почему хэш-код в виде 31 * x + y предпочтительнее чем x + y?', 90);

INSERT INTO answers (answer) VALUES (
'- getClass() получает только класс, а оператор instanceof проверяет является ли объект экземпляром класса или его потомком.'
);
INSERT INTO questions (question, answer_id) VALUES ('Чем a.getClass().equals(A.class) отличается от a instanceOf A.class ?', 91);

INSERT INTO answers (answer) VALUES (
'- Исключение — это ошибка (является объектом), возникающая во время выполнения программы. '
);
INSERT INTO questions (question, answer_id) VALUES ('Что такое исключения?', 92);

INSERT INTO answers (answer) VALUES (
'1. класс Throwable (checked).
2. от Throwable  -> Error (ошибки JVM) и Exception (checked общие).
3. от Exception
- > RuntimeException (unchecked)
- > IOException, SQLException, ReflectiveOperationException (checked).
4. RuntimeException (unchecked):
  ClassCastExceptiuon
  IndexOutOfBoundException
  AritthmeticException
  NullPointerException.

checked - зависит от программиста, unchecked - от программиста не зависит.'
);
INSERT INTO questions (question, answer_id) VALUES ('Опишите иерархию исключений.', 93);

INSERT INTO answers (answer) VALUES (
'1. Checked исключения, это те, которые должны обрабатываться блоком catch или описываться в сигнатуре метода.
Unchecked могут не обрабатываться и не быть описанными.
2. Unchecked исключения в Java — наследованные от RuntimeException, checked — от Exception.
Checked исключения отличаются от Unchecked исключения в Java, тем что
Checked исключения проверяются компилятором на этапе компиляции.
А Unchecked исключения происходит на этапе выполнения.'
);
INSERT INTO questions (question, answer_id) VALUES ('Расскажите про обрабатываемые и необрабатываемые исключения.', 94);

INSERT INTO answers (answer) VALUES (
'- Можно, чтобы в некотрых случаях программа не прекратила работу.'
);
INSERT INTO questions (question, answer_id) VALUES ('Можно ли обработать необрабатываемые исключения?', 95);

INSERT INTO answers (answer) VALUES (
'- Throw'
);
INSERT INTO questions (question, answer_id) VALUES ('Какой оператор позволяет принудительно выбросить исключение?', 96);

INSERT INTO answers (answer) VALUES (
'- Метод потенциально может выбросить исключение с указанным типом.
Передаёт обработку исключения вышестоящему методу.'
);
INSERT INTO questions (question, answer_id) VALUES ('О чем говорит ключевое слово throws?', 97);

INSERT INTO answers (answer) VALUES (
'- Необходимо унаследоваться от базового класса требуемого типа исключений (например, от Exception или RuntimeException), и переопределить методы.'
);
INSERT INTO questions (question, answer_id) VALUES ('Как создать собственное («пользовательское») исключение?', 98);

INSERT INTO answers (answer) VALUES (
'- Try - блок в котором может появиться исключение;
- Catch - блок в котором мы указываем исключение и логику его обработки;
- Finally - блок который обязательно отработает.'
);
INSERT INTO questions (question, answer_id) VALUES ('Расскажите про механизм обработки исключений в java (Try-catch-finally).', 99);

INSERT INTO answers (answer) VALUES (
'- try может быть в паре с finally, без catch. Работает это точно так же - после выхода из блока try выполняется блок finally.'
);
INSERT INTO questions (question, answer_id) VALUES ('Возможно ли использование блока try-finally (без catch)?', 100);

INSERT INTO answers (answer) VALUES (
'- Да.'
);
INSERT INTO questions (question, answer_id) VALUES ('Может ли один блок catch отлавливать сразу несколько исключений?', 101);

INSERT INTO answers (answer) VALUES (
'- Да, кроме случаев завершения работы программы или JVM:
1. Finally может не выполниться в случае если в блоке try вызывает System.exit(0),
2. Runtime.getRuntime().exit(0), Runtime.getRuntime().halt(0) и если во время исполнения блока try виртуальная машина выполнила недопустимую операцию и будет закрыта.
3. В блоке try{} бесконечный цикл.'
);
INSERT INTO questions (question, answer_id) VALUES ('Всегда ли выполняется блок finally? Существуют ли ситуации, когда блок finally не будет выполнен?', 102);

INSERT INTO answers (answer) VALUES (
'- Может. И оно будет передано в виртуальную машину Java (JVM).
Для случая с методом main произойдет две вещи:
- будет завершен главный поток приложения;
- будет вызван ThreadGroup.uncaughtException.'
);
INSERT INTO questions (question, answer_id) VALUES ('Может ли метод main() выбросить исключение во вне и если да, то где будет происходить обработка данного исключения?', 103);

INSERT INTO answers (answer) VALUES (
'- От наследника к предку.'
);
INSERT INTO questions (question, answer_id) VALUES ('В каком порядке следует обрабатывать исключения в catch блоках?', 104);

INSERT INTO answers (answer) VALUES (
'- Дает возможность объявлять один или несколько ресурсов в блоке try, которые будут закрыты автоматически без использования finally блока.
В качестве ресурса можно использовать любой объект, класс которого реализует интерфейс java.lang.AutoCloseable или java.io.Closeable.

>>> Closeable это наследник AutoCloseable.'
);
INSERT INTO questions (question, answer_id) VALUES ('Что такое механизм try-with-resources?', 105);

INSERT INTO answers (answer) VALUES (
'- finally-секция может «перебить» throw/return при помощи другого throw/return.'
);
INSERT INTO questions (question, answer_id) VALUES ('Что произойдет если исключение будет выброшено из блока catch после чего другое исключение будет выброшено из блока finally?', 106);

INSERT INTO answers (answer) VALUES (
'- В try-with-resources добавленна возможность хранения "подавленных" исключений, и брошенное try-блоком исключение имеет больший приоритет, чем исключения получившиеся во время закрытия.'
);
INSERT INTO questions (question, answer_id) VALUES ('Что произойдет если исключение будет выброшено из блока catch после чего другое исключение будет выброшено из метода close() при использовании try-with-resources?', 107);

INSERT INTO answers (answer) VALUES (
'- Сериализация это процесс сохранения состояния объекта в последовательность байт;
Реализована через интерфейс - маркер Serializable. '
);
INSERT INTO questions (question, answer_id) VALUES ('Что такое сериализация и как она реализована в Java?', 108);

INSERT INTO answers (answer) VALUES (
'- Для компактного сохранения состояния объекта и считывание этого состояния.'
);
INSERT INTO questions (question, answer_id) VALUES ('Для чего нужна сериализация?', 109);

INSERT INTO answers (answer) VALUES (
'Процесс сериализации:
1. Класс сериализуемого объекта должен реализовывать интерфейс Serializable.
2. Создать поток ObjectOutputStream (oos), который записывает объект в переданный OutputStream.
3. Записать в поток: oos.writeObject(Object);
4. Сделать oos.flush() и oos.close().
Для сериализации объектов в поток используется класс ObjectOutputStream. Он записывает данные в поток.
void writeObject(Object obj): записывает в поток отдельный объект.
void close(): закрывает поток.
void flush(): очищает буфер и сбрасывает его содержимое в выходной поток.

Для десериализации – ObjectInputStream.
Object readObject(): считывает из потока объект.
void close(): закрывает поток. '
);
INSERT INTO questions (question, answer_id) VALUES ('Опишите процесс сериализации/десериализации с использованием Serializable.', 110);

INSERT INTO answers (answer) VALUES (
'- Использовать интерфейс Externalizable.
- Переопределить методы:
* writeExternal(ObjectOutput out) throws IOException;
* readExternal(ObjectInput in) throws IOException, ClassNotFoundException;'
);
INSERT INTO questions (question, answer_id) VALUES ('Как изменить стандартное поведение сериализации/десериализации?', 111);

INSERT INTO answers (answer) VALUES (
'1. Добавить к полю модификатор transient. В таком случае после восстановления его значение будет null.
2. Сделать поле static. Значения статических полей автоматически не сохраняются.
3. Поля с модификатором final сериализуются как и обычные. За одним исключением – их невозможно десериализовать при использовании Externalizable, поскольку final-поля должны быть инициализированы в конструкторе, а после этого в readExternal изменить значение этого поля будет невозможно.
Соответственно, если необходимо сериализовать объект с final-полем неоходимо использовать только стандартную сериализацию.'
);
INSERT INTO questions (question, answer_id) VALUES ('Какие поля не будут сериализованы при сериализации? Будет ли сериализовано final поле?', 112);

INSERT INTO answers (answer) VALUES (
'- Для создания собственного протокола нужно просто переопределить writeExternal() и readExternal().
В отличие от двух других вариантов сериализации, здесь ничего не делается автоматически. Протокол полностью в ваших руках. '
);
INSERT INTO questions (question, answer_id) VALUES ('Как создать собственный протокол сериализации?', 113);

INSERT INTO answers (answer) VALUES (
'- Поле private static final long serialVersionUID - содержит уникальный идентификатор версии сериализованного класса.
Оно вычисляется по содержимому класса - полям, их порядку объявления, методам, их порядку объявления.
Соответственно, при любом изменении в классе это поле поменяет свое значение.
 Если мы не объявляем его явно, Java делает это за нас.'
);
INSERT INTO questions (question, answer_id) VALUES ('Какая роль поля serialVersionUID в сериализации?', 114);

INSERT INTO answers (answer) VALUES (
'- Вы должны изменить serialVersionUID только тогда, когда вы сознательно хотите нарушить совместимость со всеми существующими сериализациями,
например, когда изменения в вашем классе сделают его настолько семантически отличным, что у вас не будет выбора - в этом случае вы действительно должны несколько раз подумать о том, что вы на самом деле делаете.'
);
INSERT INTO questions (question, answer_id) VALUES ('Когда стоит изменять значение поля serialVersionUID?', 115);

INSERT INTO answers (answer) VALUES (
'- Проблема:
В том что после десериализации мы получим другой объект.
Таким образом, сериализация дает возможность создать Singleton еще раз, что не совсем нужно.

- Решение:
В классе определяется метод с сигнатурой
"Object readResolve() throws ObjectStreamException"

// Назначение этого метода - возвращать замещающий объект вместо объекта, на котором он вызван.'
);
INSERT INTO questions (question, answer_id) VALUES ('В чем проблема сериализации Singleton?', 116);

INSERT INTO answers (answer) VALUES (
'- В Java, есть 3 способа клонирования объекта:
1. С использованием интерфейса Cloneable;
Первый способ подразумевает, что вы будете использовать механизм так называемого «поверхностного клонирования» и сами позаботитесь
о клонировании полей-объектов.
Метод clone() в родительском классе Object является protected, поэтому требуется переопределение его с объявлением как public.
Он возвращает экземпляр объекта с копированными полями-примитивами и ссылками.
И получается что у оригинала и его клона поля-ссылки указывают на одни и те же объекты.
2. С использованием конструктора клонирования объекта;
В классе описывается конструктор, который принимает объект этого же класса и инициализирует значениями его полей поля нового объекта.
3. С использованием сериализации.
Он заключается в сохранении объекта в поток байтов с последующей эксгумацией его от туда.'
);
INSERT INTO questions (question, answer_id) VALUES ('Расскажите про клонирование объектов.', 117);

INSERT INTO answers (answer) VALUES (
'- Поверхностное копирование копирует настолько малую часть информации, насколько это возможно.
По умолчанию, клонирование в Java является поверхностным, т.е. Object class не знает о структуре класса, которого он копирует.
- Глубокое копирование дублирует все. Глубокое копирование — это две коллекции, в одну из которых дублируются все элементы оригинальной коллекции. '
);
INSERT INTO questions (question, answer_id) VALUES ('В чем отличие между поверхностным и глубоким клонированием?', 118);

INSERT INTO answers (answer) VALUES (
'- Наиболее безопасным и следовательно предпочтительным способом клонирования является использование специализированного конструктора копирования:
Отсутствие ошибок наследования (не нужно беспокоиться, что у наследников появятся новые поля, которые не будут склонированы через метод clone());
Поля для клонирования указываются явно;
Возможность клонировать даже final поля.'
);
INSERT INTO questions (question, answer_id) VALUES ('Какой способ клонирования предпочтительней?', 119);

INSERT INTO answers (answer) VALUES (
'- Метод clone() объявлен в классе Object с сигнатурой native, чтобы обеспечить доступ к стандартному механизму "поверхностного копирования" объектов (копируются значения всех полей, включая ссылки на сторонние объекты);
Он объявлен, как protected, чтобы нельзя было вызвать этот метод у не переопределивших его объектов. '
);
INSERT INTO questions (question, answer_id) VALUES ('Почему метод clone() объявлен в классе Object, а не в интерфейсе Cloneable?', 120);

INSERT INTO answers (answer) VALUES (
'- Глубокое клонирование требует выполнения следующих правил:
* Нет необходимости копировать отдельно примитивные данные;
* Все классы-члены в оригинальном классе должны поддерживать клонирование. Для каждого члена класса должен вызываться super.clone() при переопределении метода clone();
* Если какой-либо член класса не поддерживает клонирование, то в методе клонирования необходимо создать новый экземпляр этого класса и скопировать каждый его член со всеми атрибутами в новый объект класса, по одному.
Способы:
1. Сериализация – это еще один способ глубокого копирования. Мы просто сериализуем нужный объект и десериализуем его. Очевидно, объект должен поддерживать интерфейс Serializable. Мы сохраняет объект в массив байт и потом прочитать из него.
2. При помощи библиотеки DeepCloneable.
Глубокое клонирование с этой библиотекой сводится к двум строкам кода:
Cloner cloner = new Cloner();
DeepCloneable clone = cloner.deepClone(this);  '
);
INSERT INTO questions (question, answer_id) VALUES ('Как создать глубокую копию объекта? (2 способа).', 121);





